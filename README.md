# dockerTest
hellwoeld Docker app, basic docker application including docker build file 

A Quick introduction to Docker

Docker is a software platform that enables developers to develop, ship, and run applications anywhere with the help of containers.


Spring Boot with Docker: Dockerizing a Spring Boot application


Defining a docker image with Dockerfile
Go to the application’s root directory and create a new file named Dockerfile.

Dockerfile is where we define the docker image and specify all the configurations required to run the app. Following is the Dockerfile for our spring boot application -

# Start with a base image containing Java runtime
FROM openjdk:8-jdk-alpine

# Add Maintainer Info
LABEL maintainer="callicoder@gmail.com"

# Add a volume pointing to /tmp
VOLUME /tmp

# Make port 8080 available to the world outside this container
EXPOSE 8080

# The application's jar file
ARG JAR_FILE=target/hellworlddocker-snapshot

# Add the application's jar to the container
ADD ${JAR_FILE} websocket-demo.jar

# Run the jar file 
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/websocket-demo.jar"]
The Dockerfile is very simple and declarative. Let’s go through each line of the Dockerfile and understand the details.

FROM: A docker image can use another image available in the docker registry as its base or parent image. In the above example, we use the openjdk:8-jdk-alpine image as our base image. It is a very lightweight OpenJDK 8 runtime image that uses Alpine Linux. (It’s perfect for small Java microservices.)

LABEL: The LABEL instruction is used to add metadata to the image. In the above Dockerfile, we have added some info about the maintainer of the image through LABEL instruction.

VOLUME: Volumes are a mechanism to persist data generated by the container on the Host OS, and share directories from the Host OS with the container.

The VOLUME instruction creates a mount point on the container with the specified path. When you run the container, you can specify the directory on the Hot OS to which the given mount point will be mapped to. After that, anything that the container writes to the mounted path is written to the mapped directory on the Host OS.

One of the most common use cases of volumes is to store the log files generated by the container on the Host OS. For example, Let’s say that your application writes log files to a location /var/log/app.log.

You can mount a VOLUME with path /var/log in the Dockerfile, and then specify the directory on the Host OS to which this mount point will be mapped to while running the container. After that, you’ll be able to access the logs from the mapped directory on the Host OS.

In the above Dockerfile, we created a mount point with path /tmp because this is where the spring boot application creates working directories for Tomcat by default. Although it’s not required for this spring boot application because who cares about tomcat directories. But if you want to store stuff like tomcat access logs, then VOLUMES are very useful.

You can learn more about Volumes from the official documentation.

EXPOSE: As the name suggests, this instruction allows you to expose a certain port to the outside world.

ARG: The ARG instruction defines a variable with a default value. You can override the default value of the variable by passing it at build time.

ARG <name>[=<default value>]
Once defined, the variable can be used by the instructions following it.

ADD: The ADD instruction is used to copy new files and directories to the docker image.

ENTRYPOINT: This is where you configure how the application is executed inside the container.

3. Building the Docker image
Now that we have defined the Dockerfile, let’s build a docker image for our application.

Before building the docker image, you need to make sure that you’ve packaged the application in the form of a jar file using maven. You can type the following command from the root directory of the project to package it -
